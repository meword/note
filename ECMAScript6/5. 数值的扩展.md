### 二进制和八进制表示法

ES6 提供了二进制和八进制数值的新的写法，分别用前缀`0b`（或`0B`）和`0o`（或`0O`）表示

```javascript
0b111110111 === 503 // true
0o767 === 503 // true
```

从 ES5 开始，在严格模式之中，八进制就不在允许使用前缀`0`表示，ES6 进一步明确，要使用前缀`0o`表示

```javascript
// 非严格模式
(function() {
    console.log(0o11 === 011);
})()	// true

// 非严格模式
(function() {
    'use strict';
    console.log(0o11 === 011);
})()	// Uncaught SyntaxError: Octal literals are not allowed in strict mode.
```

如果要将`0b`和`0o`前缀的字符串数值转为十进制，要使用`number`方法

```javascript
Number('0b111');	// 7
Number('0o10');		// 8
```



### Number.isFinite(), Number.isNaN()

ES6 在`number`对象上，新提供了`Number.isFinite()`和`number.isNaN()`两个方法

`Number.isFinite()`用来检查一个数值是否为有限的（finite），既不是`Infinity`

```javascript
Number.isFinite(15);	// true
Number.isFinite(0.8);	// true
Number.isFinite(NaN);	// false
Number.isFinite(Infinity);	// false
Number.isFinite(-Infinity);	// false
Number.isFinite('foo');	// false
Number.isFinite('15');	// false
Number.isFinite(true);	// false
```

注意，如果参数类型不是数值，`Number.isFinite`一律返回`false`

`Number.isNaN()`用来检查一个值是否为`NaN`

```javascript
Number.isNaN(NaN)	// true
Number.isNaN(15)	// false
Number.isNaN('15')	// false
Number.isNaN(true)	// false
Number.isNaN(9/NaN)	// true
Number.isNaN('true' / 0)	// true
Number.isNaN('true' / 'true')	// true
```

如果参数类型不是`NaN`，`Number.isNaN`一律返回`false`

它们与传统的全局方法`isFinite()`和`isNaN`的区别在于，传统方法先调用`Number()`将非数值的值转为数值，在进行判断，而这两个新方法支队数值有效，`Number.isFinite()`对于非数值一律返回`false`，`Number.isNaN()`只有对于`NaN`才返回`true`，非`NaN`一律返回`false`

```javascript
isFinite(25)	// true
isFinite('25')	// true
Number.isFinite(25)	// true
Number.isFinite('25')	// false

isNaN(NaN)		// true
isNaN('NaN')	// true
Number.isNaN(NaN)	// true
Number.isNaN('NaN')	// false
```



### Number.parseInt(), Number.parseFloat()

ES6 将全局方法`parseInt()`和`parseFloat()`，移植到`Number`对象上面，行为完全保持不变

```javascript
// ES5的写法
parseInt('12.34')	// 12
parseFloat('123.45#')	// 123.45

// ES6的写法
Number.parseInt('12.34')	// 12
Number.parseFloat('123.45#')	// 123.45
```



### Number.isInteger()

`Number.isInteger()`用来判断一个数值是否为整数

```javascript
Number.isInteger(25)	// true
Number.isInteger(25.1)	// false
```

JavaScript内部，整数和浮点数采用的是同样的储存方法，所以 25 和 25.0 被视为同一个值

```javascript
Number.isInteger(25)	// true
Number.isInteger(25.0)	// true
```

如果参数不是数值，`Number.isInteger`返回`false`

```javascript
Number.isInteger()		// false
Number.isInteger(null)	// false
Number.isInteger('15')	// false
Number.isInteger(true)	// false
```

注意：由于 JavaScript 采用 IEEE 754 标准，数值存储为64为双精度格式，数值精度最多可以达到53个二进制位（1个隐藏位与 52个有效位）。如果数值的精度超过这个限度，第54位及后面的位就会被丢弃，这种情况下，`Number.isInteger`可能会误判

```javascript
Number.isInteger(3.0000000000000002)	// true
```

上面代码中，`Number.isInteger`的参数明明不是整数，但是会返回`true`。原因就是这个小数的精度达到了小数点后16个十进制位，转成二进制位超过了53个二进制位，导致最后那个`2`被丢弃了

类似的情况还有，如果一个数值的绝对值小于`Number.MIN_VALUE`（5E-324），即小于 JavaScript 能够分辨的最小值，会被自动转为 0。这时，`Number.isInteger`也会误判

```javascript
Number.isInteger(5E-324)	// false
Number.isInteger(5E-325)	// true
```

上面代码中，`5E-325`由于值太小，会被自动转为0，因此返回`true`

总之，如果对数据精度的要求较高，不建议使用`Number.isInteger()`判断一个数值是否为整数



### Number.EPSILON

ES6 在`Number`对象上面，新增一个极小的常量`Number.EPSILON`。根据规格，它表示 1 与大于 1 的最小浮点数之间的差

对于 64 位浮点数来说，大于 1 的最小浮点数相当于二进制的`1.00..001`，小数点后面有联系 51 个零。这个值减去 1 之后，就等于 2 的 -52 次方

```javascript
Number.EPSILON === Math.pow(2, -52)	// true
Number.EPSILON	// 2.220446049250313e-16
Number.EPSILON.toFixed(20)	// "0.00000000000000022204"
```

`Number.EPSILON`实际上是 JavaScript 能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了

引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。我们知道浮点数计算是不精确的

```javascript
0.1 + 0.2
// 0.30000000000000004

0.1 + 0.2 - 0.3
// 5.551115123125783e-17

5.551115123125783e-17.toFixed(20)
// '0.00000000000000005551'
```

上面代码解释了，为什么比较`0.1 + 0.2`与`0.3`得到的结果是`false`

```javascript
0.1 + 0.2 === 0.3	// false
```

`Number.EPSILON`可以用来设置“能够接受的误差范围”。比如，误差范围设为 2 的-50次方（即`Number.EPSILON * Math.pow(2, 2)`），即如果两个浮点数的差小于这个值，我们就认为这两个浮点数相等

```javascript
5.551115123125783e-17 < Number.EPSILON * Math.pow(2, 2)
// true
```

因此，`Number.EPSILON`的实质是一个可以接受的最小误差范围

```javascript
function withinErrorMargin (left, right) {
    return Math.abs(left - right) < Number.EPSILON * Math.pow(2, 2);
}

0.1 + 0.2 === 0.3;	// false
withinErrorMargin(0.1 + 0.2, 0.3);	// true

1.1 + 1.3 === 2.4;	// false
withinErrorMargin(1.1 + 1.3, 2.4);	// true
```

上面的代码为浮点数运算，部署了一个误差检查函数



### 安全整数和 Number.isSafeInteger()

JavaScript 能够准确表示的整数范围在`-2^53`到`2^53`之间（不含两个端点），超过这个范围，无法精确表示这个值

```javascript
Math.pow(2, 53);	// 9007199254740992

9007199254740992	// 9007199254740992
9007199254740992	// 9007199254740992

Math.pow(2, 53) === Math.pow(2, 53) + 1;
// true
```

上面代码中，超出 2 的 53 次方之后，一个数就不精确了

ES6 引入了`Number.MAX_SAFE_INTEGER`和`Number.MIN_SAFE_INTEGER`这两个常量，用来表示这个范围的上下限

```javascript
Number.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1
// true
Number.MAX_SAFE_INTEGER === 9007199254740991
// true

Number.MIN_SAFE_INTEGER === -Number.MAX_SAFE_INTEGER
// true
Number.MIN_SAFE_INTEGER === -9007199254740991
// true
```

上面代码中，可以看到JavaScript 能够精确表示的极限

`Number.isSafeInteger()`则是用来判断一个整数是否落在这个范围之内

```javascript
Number.isSafeInteger('a');	// false
Number.isSafeInteger(null);	// false
Number.isSafeInteger(NaN);	// false
Number.isSafeInteger(Infinity);	// false
Number.isSafeInteger(-Infinity);	// false

Number.isSafeInteger(3);	// true
Number.isSafeInteger(1.2);	// false
Number.isSafeInteger(9007199254740990);	// ture
Number.isSafeInteger(9007199254740992);	// false

Number.isSafeInteger(Number.MIN_SAFE_INTEGER - 1);	// false
Number.isSafeInteger(Number.MIN_SAFE_INTEGER);	// true
Number.isSafeInteger(Number.MAX_SAFE_INTEGER);	// true
Number.isSafeInteger(Number.MAX_SAFE_INTEGER + 1);	// true
```

这个函数的实现很简单，就是跟安全整数的两个边界值比较一下

```javascript
Num
```



















